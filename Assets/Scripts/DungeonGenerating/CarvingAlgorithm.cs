using System.Collections.Generic;
using UnityEngine;

namespace CoED
{
    public static class CarvingAlgorithm
    {
        /// <summary>
        /// Executes the selected carving algorithm to generate floor tiles.
        /// </summary>
        /// <param name="algorithmType">The carving algorithm to use.</param>
        /// <param name="settings">Dungeon settings containing parameters for the selected algorithm.</param>
        /// <param name="bounds">The bounds within which tiles should be generated.</param>
        /// <returns>A set of floor tiles generated by the algorithm.</returns>
        public static HashSet<Vector2Int> Execute(CarvingAlgorithmType algorithmType, DungeonSettings settings, RectInt bounds)
        {
                Debug.Log($"Executing carving algorithm: {algorithmType} with bounds ({bounds.x}, {bounds.y}, {bounds.width}, {bounds.height}).");

            switch (algorithmType)
            {
                case CarvingAlgorithmType.CellularAutomata:
                    return CellularAutomata(settings, bounds);

                case CarvingAlgorithmType.PerlinNoise:
                    return PerlinNoise(settings, bounds);

                case CarvingAlgorithmType.BSP:
                    return BSP(settings, bounds);

                default:
                    Debug.LogError($"Unknown algorithm type: {algorithmType}");
                    return new HashSet<Vector2Int>();
            }
        }

        /// <summary>
        /// Cellular Automata Algorithm for floor generation.
        /// </summary>
private static HashSet<Vector2Int> CellularAutomata(DungeonSettings settings, RectInt bounds)
{
    HashSet<Vector2Int> floorTiles = new HashSet<Vector2Int>();
    bool[,] map = new bool[bounds.width, bounds.height];

    // Initialize the map with random walls based on initial wall density
    for (int x = 0; x < bounds.width; x++)
    {
        for (int y = 0; y < bounds.height; y++)
        {
            map[x, y] = Random.value < settings.initialWallDensity;
        }
    }

    // Perform Cellular Automata smoothing
    for (int i = 0; i < settings.cellularAutomataIterations; i++)
    {
        bool[,] newMap = new bool[bounds.width, bounds.height];
        for (int x = 0; x < bounds.width; x++)
        {
            for (int y = 0; y < bounds.height; y++)
            {
                int neighborCount = CountNeighbors(map, x, y, bounds);
                newMap[x, y] = neighborCount >= settings.neighborWallThreshold;
            }
        }
        map = newMap;
    }

    // Convert map to floor tiles (invert the logic)
    for (int x = 0; x < bounds.width; x++)
    {
        for (int y = 0; y < bounds.height; y++)
        {
            if (map[x, y]) // Cells marked as 'true' (initially walls) become floors
            {
                floorTiles.Add(new Vector2Int(x + bounds.xMin, y + bounds.yMin));
            }
        }
    }

    return floorTiles;
}

private static int CountNeighbors(bool[,] map, int x, int y, RectInt bounds)
{
    int count = 0;
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            if (dx == 0 && dy == 0) continue; // Skip self

            int nx = x + dx;
            int ny = y + dy;

            if (nx >= 0 && nx < bounds.width && ny >= 0 && ny < bounds.height && map[nx, ny])
            {
                count++;
            }
        }
    }
    return count;
}


        /// <summary>
        /// Perlin Noise Algorithm for floor generation.
        /// </summary>
        private static HashSet<Vector2Int> PerlinNoise(DungeonSettings settings, RectInt bounds)
        {
            HashSet<Vector2Int> floorTiles = new HashSet<Vector2Int>();
            float scale = settings.edgeBias; // Adjust scale based on settings

            for (int x = 0; x < bounds.width; x++)
            {
                for (int y = 0; y < bounds.height; y++)
                {
                    float noiseValue = Mathf.PerlinNoise(x / scale, y / scale);
                    if (noiseValue > 0.5f) // Threshold for floor tiles
                    {
                        floorTiles.Add(new Vector2Int(x + bounds.xMin, y + bounds.yMin));
                    }
                }
            }

            return floorTiles;
        }

        /// <summary>
        /// Binary Space Partitioning Algorithm for floor generation.
        /// </summary>
        private static HashSet<Vector2Int> BSP(DungeonSettings settings, RectInt bounds)
        {
            HashSet<Vector2Int> floorTiles = new HashSet<Vector2Int>();
            List<RectInt> rooms = new List<RectInt>();

            // Initialize root space
            Queue<RectInt> spaces = new Queue<RectInt>();
            spaces.Enqueue(bounds);

            // Subdivide space
            for (int i = 0; i < settings.bspSubdivisions; i++)
            {
                int count = spaces.Count;
                for (int j = 0; j < count; j++)
                {
                    RectInt space = spaces.Dequeue();
                    if (Random.value < settings.bspCarveChance)
                    {
                        SplitSpace(space, spaces);
                    }
                    else
                    {
                        rooms.Add(space);
                    }
                }
            }

            // Convert rooms to floor tiles
            foreach (var room in rooms)
            {
                for (int x = room.xMin; x < room.xMax; x++)
                {
                    for (int y = room.yMin; y < room.yMax; y++)
                    {
                        floorTiles.Add(new Vector2Int(x, y));
                    }
                }
            }

            return floorTiles;
        }

        private static void SplitSpace(RectInt space, Queue<RectInt> spaces)
        {
            bool splitVertically = Random.value > 0.5f;
            if (splitVertically)
            {
                int splitX = Random.Range(space.xMin + 1, space.xMax - 1);
                spaces.Enqueue(new RectInt(space.xMin, space.yMin, splitX - space.xMin, space.height));
                spaces.Enqueue(new RectInt(splitX, space.yMin, space.xMax - splitX, space.height));
            }
            else
            {
                int splitY = Random.Range(space.yMin + 1, space.yMax - 1);
                spaces.Enqueue(new RectInt(space.xMin, space.yMin, space.width, splitY - space.yMin));
                spaces.Enqueue(new RectInt(space.xMin, splitY, space.width, space.yMax - splitY));
            }
        }
    }
}
